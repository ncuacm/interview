### 1、进程，线程和协程的区别

+ 线程和进程都是同步机制，而协程是异步机制。
+ 线程是抢占式的，协程是非抢占式的。在某一个时刻只能有一个线程被执行。
+ 一个线程可以有多个协程，一个进程也可以有多个协程。
+ 协程不被操作系统内核管理，完全是由程序控制，线程是被分割的CPU资源，协程是组织好的代码流程，线程是协程的资源。但是协程不会致谢使用线程，而是利用执行器关联任意的线程或者协程池。
+ 协程可以保留上一次调用的时候的状态。
+ 进程和线程的切换流程
  + 进程的切换是通过切换页表来使用新的地址空间，一旦出现了上下文切换，处理器里面所有缓存的内存地址都作废了。
  + 切换内核栈和硬件上下文。
+ 进程和线程同步的方式
  + 使用临界区。通过多线程的串行化来访问公共资源或者一段代码。速度快，同时适合控制数据访问。
  + 互斥量。为了协调共同对某一个资源的单独访问而设计的。
  + 信号量。为了控制一个具有有限数量用户资源而设计的，它可以允许多个线程在同一个时刻访问同一个资源，但是对访问这个资源的最大线程的数量有限制。
  + 事件。

### 2、进程

+ 进程是对操作系统的一个正在运行的程序的抽象，进程是资源分配的最小单位。为什么要有进程？进程是为了合理压榨CPU的性能和分配运行的时间片，单个CPU一次只能执行一个任务，如果一个进程跑着，那么唯一一个把CPU完全占住了，这是不合理的。
+ 一个进程可以由多个线程的执行单元组成，每个线程都运行在进程中，共享着同样的代码和数据。进程之间更加容易共享数据，在上下文切换中一般比进程高效。
+ 进程之间的通信
  + 管道。可以分为单向管道和双向管道。分别代表数据流动的方向。同时也可以分为匿名管道和命名管道，匿名管道是一种单向的，一般是用于有亲源关系之间的进程通信使用，还有一种是命名管道，这种管道是以磁盘的方式存在的，可以用于不同的进程之间通信使用。
  + 信号。信号是一种比较复杂的通信方式，信号可以在任何一个时刻发给某一个进程。而无需知道该进程的状态。
  + 信号量。信号量可以理解为一个计时器。可以用来控制多个进程对共享资源的访问。可以作为一种锁的机制。
  + 消息队列。是一个链表，存放在内核里面。
  + 共享内存。
  + socket通信。主要用于不同的机器之间的进程通信。
+ 进程切换的步骤
  + 保存处理机的上下文，包括程序计数器和寄存器。
  + 更新PCB的信息。
  + 把进程的PCB移到相应的队列里面，比如说就绪，阻塞等队列里面。
  + 选择另一个进程执行，并且更新其PCB。
  + 更新内存管理的数据结构。
  + 恢复上下文。


### 3、线程

+ 线程是进程的一个实体，是CPU调度和分配的基本单位，它比进程具有更小的可以独立运行的基本单位。在一个进程里面可以有多个线程，这些线程之间可以互相进行通信和来回进行切换。线程可以理解为轻量级的进程。

+ 为什么要有线程？
  + 进程之间通信难以进行数据的共享，父子进程之间没有共享内存，需要通过进程之间通信(IPC),进程之间交换信息，性能开销大。
  + 创建进程的开销大。
+ 线程的分类
  + 线程可以分为用户级线程和内核级线程。内核级的线程指的是内核支持的线程或者是轻量级的线程。无论是在用户程序中创建的线程或者是在系统中创建的线程，它们的创建，销毁都是由内核实现的。
  + 用户级的线程。他们仅存在于用户级别里，他们不依赖于操作系统的核心，利用线程库来完成它的创建和管理。速度比较快，操作系统内核无法感知用户级的线程的存在。
+ 线程之间的同步
  + 信号量，我们可以通过信号量来控制资源访问的权限，我们利用互斥的信号量来表示资源之可以被一个线程同时访问，这样就可以保证资源不会被多个线程共同占用了。
  + 信号量，允许多个线程同一个时刻访问同一个资源类型，但是不允许同一个时间超过允许的最大的线程的数量。
  + 事件，使用通知的方式保持多个线程之间的同步，这样还可以设置不同的线程之间的优先级关系。这个可以理解为一个线程执行完任务之后去主动唤醒另一个线程去执行任务。


### 4、协程

+ 协程是用户态的线程。在创建协程的时候，会从进程的堆中分配一段内存作为协程的栈。
+ 优势
  + 节省CPU，协程可以避免内核级别线程的上下文切换，避免了CPU资源的浪费。而协程是用户态的线程，用户可以自行进行创建和销毁。从而避免了频繁的系统级别的线程上下文切换。
  + 节省内存，在64位的Linux，一个线程通常需要8M的栈内存和64M的堆内存。系统内存的资源限制导致了我们无法开启更多的线程执行高并发，但是协程却可以创建数十万个。
  + 稳定性，线程之间通过共享内存来共享数据，如果一个线程出现了问题，同一个进程内的所有的线程都会崩溃。
  + 开发效率，在利用协程进行开发的时候，可以很容易的实现一些IO操作异步化。
+ 协程之间的通信
  + 协程之间一般是通过共享变量的方法来进行通信的，但是这样会给共享内存的多线程造成困难。
  + 在Go语言中，一般是通过channel进行通信的，这种通道方式保证了数据的同步性，同一个时间内只有一个线程可以访问数据，不会出现数据的竞争的现象。

### 5、交换空间
+ 当我们的内存不足的时候，我们会将内存中一部分不用的数据放进磁盘空间里面，让出宝贵的内存给需要用的进程。当再次需要这部分的时候再次从磁盘空间里面转到内存中，磁盘空间的那块区间就是我们的交换空间，虚拟内存的空间就是我们的内存空间和磁盘空间的总的空间的大小。

+ 为什么切换虚拟地址空间会比较耗费时间?
  + 每个进程都有自己的虚拟地址空间，把虚拟地址转化为物理地址需要查找页表，查找页表是一个很慢的过程，因此我恩通常使用Cache来缓存常用的地址映射。但是在操作系统里面经常使用Cache来缓存常用的地址映射。这样可以加速页表的查询。
  + 但是在我们进行进程的切换的时候，同时需要进行页表的切换，这样的话，那个Cache缓存的一些地址映射也就消失了。

### 6、死锁

+ 死锁就是多个进程之间因为竞争关系而造成的一种僵局，若没有外力的作用，那么系统就会一直维持这种状态，各个参与的进程之间就没有办法继续推进执行任务了。

+ 死锁的条件
  + 互斥条件，一个资源一次只能被一个进程所使用
  + 请求和保持条件，一个资源因为请求资源而阻塞的时候，对自己持有的资源保持不放
  + 不可剥夺条件，进程获得资源，在没有完全使用完之前，不能被强行剥夺。
  + 循环等待条件，若干个进程之间形成了一种头尾相接的循环等待关系。
+ 破坏死锁
  + 破坏死锁的方法就是破坏死锁的几个条件中的一个就可以了。
  + 具体的策略有鸵鸟策略，资源剥夺，进程回退，检测和接触死锁。
    + 鸵鸟策略，这是一种忽略死锁的方法，假设死锁没有发生，这种一般用在接触死锁的花费很大的情况下。
    + 资源剥夺，他允许进程可以剥夺其他进程的资源。
    + 进程回退，让进程回退到之前的某一个状态，从而释放了已经获得的资源了。
    + 按照某种顺序，撤销进程的资源，直到释放了足够的资源。

### 7、进程调度

+ 进程调度策略
  + 先来先服务，这个可以使用队列实现。
  + 短作业优先。按照执行的时间长短来进行调度，短的先执行，但是这种调度算法很有可能造成需要长时间服务的作业饿死。
  + 最短剩余时间优先。按照剩余运行时间的顺序进行调度。
  + 时间片轮转。所有进程先排成一个队列，然后，在每次进行调度的时候，把CPU的时间分配给队首进程，同时执行一个时间片，当执行万之后，把这个进程放到队列的尾部去。
  + 优先级调度。为每个进程分配一个优先级，按照优先级进行调度。

### 8、IO多路复用
+ 这个是面试的必考点，建议自己使用C/C++手动实现一次。
+ IO多路复用是一种同步IO的模型，实现一个进程监视多个文件句柄。一旦某一个文件就绪了，就可以通知应用程序进行相应的读写操作。如果没有进程就绪就会阻塞进程，交出CPU。

+ IO多路复用的方法有三种，分别是select，poll，epoll。
+ 文件描述符，是一种用来表述执行文件的引用的抽象的描述。其实这是一个索引值，用来指向内核为每个进程所维护的该进程所打开的记录表。当程序里面的一个文件打开一个新的文件的时候，内核就会向进程返回一个文件描述符。

+ 在没有这种机制的时候，主要的方法有BIO，NIO两种方法来实现。
  + 同步阻塞，就是在accpet一个请求的时候，在recv和send调用的时候，将无法accept其他请求，也就是没有办法处理并发请求。如果采用的是多线程的方法，一个链接就需要一个线程，如果请求的数很多的时候造成的线程资源的消耗就会i很大，但其实资源的利用率是很低的。
  + 同步非阻塞，当服务器接受到一个请求的时候，就吧这个请求加入fds集合里面，每次轮询fds集合recv的数据，没有数据就会立刻返回错误，每次论询都会消耗很大的资源。

+ 讲一下IO多路复用
  + IO多路复用值的是内核一旦发现进程的指定的一个或者多个IO条件准备读取，那么就会通知该进程。IO多路先利用单线程获取fd列表，遍历有时间的fd，使得可以支持更多的并发连接请求。
  + select，知道有IO事件发生了，但是不知道是那个事件，所以需要论询所有的数据流，才可以找到数据，对他们进行操作，所以时间复杂度是O(n),缺点就是单个线程只能打开1024个fd，而且每次执行select操作需要将集合从用户态拷贝内核态。
  + poll，本质上和select没有区别，都是从用户态拷贝到内核态，但是这种它没有最大连接数的限制。
  + epoll，可以理解为是事件驱动的，会直接通知是哪个事件发生了怎样的IO操作。主要的实现就是利用红黑树将事件进行挂载。同时有一个双链表，当epoll_wait检查是否有事件发生的时候，只需要检查这个链表的两端就可以了。所以epoll的高效主要是通过红黑树和双链表以及回调机制实现的。epoll没有并发的限制，没有最大连接数量的限制，只关心活跃的连接。同时利用mmap内存映射加速向内核空间的拷贝。
    + epoll_create()系统调用，此调用返回一个句柄，之后所有的使用都依靠这个句柄来进行标识。
    + epoll_ctl()系统调用，通过这个调用向epoll对象中添加，删除和修改感兴趣的事件。
    + epoll_wait()系统调用，收集epoll监控之中已经发生的事件。
    + epoll的LT和ET，LT是指水平触发，只要有数据就会触发，ET是值边缘触发，只有数据进入的时候才会触发，而不关心缓冲区里面是否有数据。

### 9、分段，分页

+ 段是信息的逻辑单位，是根据用户的需要进行划分的，因此段对用户是可见的。页是信息的物理单位，是为了管理主存方便来进行划分的，对用户是透明的，用户察觉不到。
+ 段的大小根据功能来定的，而页的大小是根据操作系统决定的。
+ 段是二维的地址，页是一维的地址。
+ 抖动：在具有虚存的计算机中，由于频繁的调页活动市访问磁盘的次数过多而造成的系统效率降低的一种现象。